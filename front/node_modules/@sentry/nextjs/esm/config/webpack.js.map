{"version":3,"file":"webpack.js","sources":["../../../src/config/webpack.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { getSentryRelease } from '@sentry/node';\nimport { dropUndefinedKeys, logger } from '@sentry/utils';\nimport { default as SentryWebpackPlugin } from '@sentry/webpack-plugin';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as path from 'path';\n\nimport {\n  BuildContext,\n  EntryPropertyObject,\n  NextConfigObject,\n  SentryWebpackPluginOptions,\n  WebpackConfigFunction,\n  WebpackConfigObject,\n  WebpackEntryProperty,\n} from './types';\n\nexport { SentryWebpackPlugin };\n\n// TODO: merge default SentryWebpackPlugin ignore with their SentryWebpackPlugin ignore or ignoreFile\n// TODO: merge default SentryWebpackPlugin include with their SentryWebpackPlugin include\n// TODO: drop merged keys from override check? `includeDefaults` option?\n\n/**\n * Construct the function which will be used as the nextjs config's `webpack` value.\n *\n * Sets:\n *   - `devtool`, to ensure high-quality sourcemaps are generated\n *   - `entry`, to include user's sentry config files (where `Sentry.init` is called) in the build\n *   - `plugins`, to add SentryWebpackPlugin (TODO: optional)\n *\n * @param userNextConfig The user's existing nextjs config, as passed to `withSentryConfig`\n * @param userSentryWebpackPluginOptions The user's SentryWebpackPlugin config, as passed to `withSentryConfig`\n * @returns The function to set as the nextjs config's `webpack` value\n */\nexport function constructWebpackConfigFunction(\n  userNextConfig: Partial<NextConfigObject> = {},\n  userSentryWebpackPluginOptions: Partial<SentryWebpackPluginOptions> = {},\n): WebpackConfigFunction {\n  // Will be called by nextjs and passed its default webpack configuration and context data about the build (whether\n  // we're building server or client, whether we're in dev, what version of webpack we're using, etc). Note that\n  // `incomingConfig` and `buildContext` are referred to as `config` and `options` in the nextjs docs.\n  const newWebpackFunction = (incomingConfig: WebpackConfigObject, buildContext: BuildContext): WebpackConfigObject => {\n    let newConfig = { ...incomingConfig };\n\n    // if user has custom webpack config (which always takes the form of a function), run it so we have actual values to\n    // work with\n    if ('webpack' in userNextConfig && typeof userNextConfig.webpack === 'function') {\n      newConfig = userNextConfig.webpack(newConfig, buildContext);\n    }\n\n    // Tell webpack to inject user config files (containing the two `Sentry.init()` calls) into the appropriate output\n    // bundles. Store a separate reference to the original `entry` value to avoid an infinite loop. (If we don't do\n    // this, we'll have a statement of the form `x.y = () => f(x.y)`, where one of the things `f` does is call `x.y`.\n    // Since we're setting `x.y` to be a callback (which, by definition, won't run until some time later), by the time\n    // the function runs (causing `f` to run, causing `x.y` to run), `x.y` will point to the callback itself, rather\n    // than its original value. So calling it will call the callback which will call `f` which will call `x.y` which\n    // will call the callback which will call `f` which will call `x.y`... and on and on. Theoretically this could also\n    // be fixed by using `bind`, but this is way simpler.)\n    const origEntryProperty = newConfig.entry;\n    newConfig.entry = async () => addSentryToEntryProperty(origEntryProperty, buildContext);\n\n    // Enable the Sentry plugin (which uploads source maps to Sentry when not in dev) by default\n    const enableWebpackPlugin =\n      // TODO: this is a hack to fix https://github.com/getsentry/sentry-cli/issues/1085, which is caused by\n      // https://github.com/getsentry/sentry-cli/issues/915. Once the latter is addressed, this existence check can come\n      // out. (The check is necessary because currently, `@sentry/cli` uses a post-install script to download an\n      // architecture-specific version of the `sentry-cli` binary. If `yarn install`, `npm install`, or `npm ci` are run\n      // with the `--ignore-scripts` option, this will be blocked and the missing binary will cause an error when users\n      // try to build their apps.)\n      ensureCLIBinaryExists() &&\n      (buildContext.isServer\n        ? !userNextConfig.sentry?.disableServerWebpackPlugin\n        : !userNextConfig.sentry?.disableClientWebpackPlugin);\n\n    if (enableWebpackPlugin) {\n      // TODO Handle possibility that user is using `SourceMapDevToolPlugin` (see\n      // https://webpack.js.org/plugins/source-map-dev-tool-plugin/)\n\n      // Next doesn't let you change `devtool` in dev even if you want to, so don't bother trying - see\n      // https://github.com/vercel/next.js/blob/master/errors/improper-devtool.md\n      if (!buildContext.dev) {\n        // `hidden-source-map` produces the same sourcemaps as `source-map`, but doesn't include the `sourceMappingURL`\n        // comment at the bottom. For folks who aren't publicly hosting their sourcemaps, this is helpful because then\n        // the browser won't look for them and throw errors into the console when it can't find them. Because this is a\n        // front-end-only problem, and because `sentry-cli` handles sourcemaps more reliably with the comment than\n        // without, the option to use `hidden-source-map` only applies to the client-side build.\n        newConfig.devtool =\n          userNextConfig.sentry?.hideSourceMaps && !buildContext.isServer ? 'hidden-source-map' : 'source-map';\n      }\n\n      newConfig.plugins = newConfig.plugins || [];\n      newConfig.plugins.push(\n        new SentryWebpackPlugin(getWebpackPluginOptions(buildContext, userSentryWebpackPluginOptions)),\n      );\n    }\n\n    return newConfig;\n  };\n\n  return newWebpackFunction;\n}\n\n/**\n * Modify the webpack `entry` property so that the code in `sentry.server.config.js` and `sentry.client.config.js` is\n * included in the the necessary bundles.\n *\n * @param currentEntryProperty The value of the property before Sentry code has been injected\n * @param buildContext Object passed by nextjs containing metadata about the build\n * @returns The value which the new `entry` property (which will be a function) will return (TODO: this should return\n * the function, rather than the function's return value)\n */\nasync function addSentryToEntryProperty(\n  currentEntryProperty: WebpackEntryProperty,\n  buildContext: BuildContext,\n): Promise<EntryPropertyObject> {\n  // The `entry` entry in a webpack config can be a string, array of strings, object, or function. By default, nextjs\n  // sets it to an async function which returns the promise of an object of string arrays. Because we don't know whether\n  // someone else has come along before us and changed that, we need to check a few things along the way. The one thing\n  // we know is that it won't have gotten *simpler* in form, so we only need to worry about the object and function\n  // options. See https://webpack.js.org/configuration/entry-context/#entry.\n\n  const { isServer, dir: projectDir, dev: isDev, config: userNextConfig } = buildContext;\n\n  const newEntryProperty =\n    typeof currentEntryProperty === 'function' ? await currentEntryProperty() : { ...currentEntryProperty };\n\n  // `sentry.server.config.js` or `sentry.client.config.js` (or their TS equivalents)\n  const userConfigFile = isServer ? getUserConfigFile(projectDir, 'server') : getUserConfigFile(projectDir, 'client');\n\n  // we need to turn the filename into a path so webpack can find it\n  const filesToInject = [`./${userConfigFile}`];\n\n  // Support non-default output directories by making the output path (easy to get here at build-time) available to the\n  // server SDK's default `RewriteFrames` instance (which needs it at runtime). Doesn't work when using the dev server\n  // because it somehow tricks the file watcher into thinking that compilation itself is a file change, triggering an\n  // infinite recompiling loop. (This should be fine because we don't upload sourcemaps in dev in any case.)\n  if (isServer && !isDev) {\n    const rewriteFramesHelper = path.resolve(\n      fs.mkdtempSync(path.resolve(os.tmpdir(), 'sentry-')),\n      'rewriteFramesHelper.js',\n    );\n    fs.writeFileSync(rewriteFramesHelper, `global.__rewriteFramesDistDir__ = '${userNextConfig.distDir}';\\n`);\n    // stick our helper file ahead of the user's config file so the value is in the global namespace *before*\n    // `Sentry.init()` is called\n    filesToInject.unshift(rewriteFramesHelper);\n  }\n\n  // inject into all entry points which might contain user's code\n  for (const entryPointName in newEntryProperty) {\n    if (shouldAddSentryToEntryPoint(entryPointName, isServer)) {\n      addFilesToExistingEntryPoint(newEntryProperty, entryPointName, filesToInject);\n    }\n  }\n\n  return newEntryProperty;\n}\n\n/**\n * Search the project directory for a valid user config file for the given platform, allowing for it to be either a\n * TypeScript or JavaScript file.\n *\n * @param projectDir The root directory of the project, where the file should be located\n * @param platform Either \"server\" or \"client\", so that we know which file to look for\n * @returns The name of the relevant file. If no file is found, this method throws an error.\n */\nexport function getUserConfigFile(projectDir: string, platform: 'server' | 'client'): string {\n  const possibilities = [`sentry.${platform}.config.ts`, `sentry.${platform}.config.js`];\n\n  for (const filename of possibilities) {\n    if (fs.existsSync(path.resolve(projectDir, filename))) {\n      return filename;\n    }\n  }\n\n  throw new Error(`Cannot find '${possibilities[0]}' or '${possibilities[1]}' in '${projectDir}'.`);\n}\n\n/**\n * Add files to a specific element of the given `entry` webpack config property.\n *\n * @param entryProperty The existing `entry` config object\n * @param entryPointName The key where the file should be injected\n * @param filepaths An array of paths to the injected files\n */\nfunction addFilesToExistingEntryPoint(\n  entryProperty: EntryPropertyObject,\n  entryPointName: string,\n  filepaths: string[],\n): void {\n  // can be a string, array of strings, or object whose `import` property is one of those two\n  const currentEntryPoint = entryProperty[entryPointName];\n  let newEntryPoint = currentEntryPoint;\n\n  if (typeof currentEntryPoint === 'string') {\n    newEntryPoint = [...filepaths, currentEntryPoint];\n  } else if (Array.isArray(currentEntryPoint)) {\n    newEntryPoint = [...filepaths, ...currentEntryPoint];\n  }\n  // descriptor object (webpack 5+)\n  else if (typeof currentEntryPoint === 'object' && 'import' in currentEntryPoint) {\n    const currentImportValue = currentEntryPoint.import;\n    let newImportValue;\n\n    if (typeof currentImportValue === 'string') {\n      newImportValue = [...filepaths, currentImportValue];\n    } else {\n      newImportValue = [...filepaths, ...currentImportValue];\n    }\n\n    newEntryPoint = {\n      ...currentEntryPoint,\n      import: newImportValue,\n    };\n  }\n  // malformed entry point (use `console.error` rather than `logger.error` because it will always be printed, regardless\n  // of SDK settings)\n  else {\n    // eslint-disable-next-line no-console\n    console.error(\n      'Sentry Logger [Error]:',\n      `Could not inject SDK initialization code into entry point ${entryPointName}, as its current value is not in a recognized format.\\n`,\n      'Expected: string | Array<string> | { [key:string]: any, import: string | Array<string> }\\n',\n      `Got: ${currentEntryPoint}`,\n    );\n  }\n\n  entryProperty[entryPointName] = newEntryPoint;\n}\n\n/**\n * Check the SentryWebpackPlugin options provided by the user against the options we set by default, and warn if any of\n * our default options are getting overridden. (Note: If any of our default values is undefined, it won't be included in\n * the warning.)\n *\n * @param defaultOptions Default SentryWebpackPlugin options\n * @param userOptions The user's SentryWebpackPlugin options\n */\nfunction checkWebpackPluginOverrides(\n  defaultOptions: SentryWebpackPluginOptions,\n  userOptions: Partial<SentryWebpackPluginOptions>,\n): void {\n  // warn if any of the default options for the webpack plugin are getting overridden\n  const sentryWebpackPluginOptionOverrides = Object.keys(defaultOptions).filter(key => key in userOptions);\n  if (sentryWebpackPluginOptionOverrides.length > 0) {\n    __DEBUG_BUILD__ &&\n      logger.warn(\n        '[Sentry] You are overriding the following automatically-set SentryWebpackPlugin config options:\\n' +\n          `\\t${sentryWebpackPluginOptionOverrides.toString()},\\n` +\n          \"which has the possibility of breaking source map upload and application. This is only a good idea if you know what you're doing.\",\n      );\n  }\n}\n\n/**\n * Determine if this is an entry point into which both `Sentry.init()` code and the release value should be injected\n *\n * @param entryPointName The name of the entry point in question\n * @param isServer Whether or not this function is being called in the context of a server build\n * @returns `true` if sentry code should be injected, and `false` otherwise\n */\nfunction shouldAddSentryToEntryPoint(entryPointName: string, isServer: boolean): boolean {\n  return (\n    entryPointName === 'pages/_app' ||\n    (entryPointName.includes('pages/api') && !entryPointName.includes('_middleware')) ||\n    (isServer && entryPointName === 'pages/_error')\n  );\n}\n\n/**\n * Combine default and user-provided SentryWebpackPlugin options, accounting for whether we're building server files or\n * client files.\n *\n * @param buildContext Nexjs-provided data about the current build\n * @param userPluginOptions User-provided SentryWebpackPlugin options\n * @returns Final set of combined options\n */\nexport function getWebpackPluginOptions(\n  buildContext: BuildContext,\n  userPluginOptions: Partial<SentryWebpackPluginOptions>,\n): SentryWebpackPluginOptions {\n  const { buildId, isServer, webpack, config: userNextConfig, dev: isDev, dir: projectDir } = buildContext;\n  const distDir = userNextConfig.distDir ?? '.next'; // `.next` is the default directory\n\n  const isWebpack5 = webpack.version.startsWith('5');\n  const isServerless = userNextConfig.target === 'experimental-serverless-trace';\n  const hasSentryProperties = fs.existsSync(path.resolve(projectDir, 'sentry.properties'));\n  const urlPrefix = userNextConfig.basePath ? `~${userNextConfig.basePath}/_next` : '~/_next';\n\n  const serverInclude = isServerless\n    ? [{ paths: [`${distDir}/serverless/`], urlPrefix: `${urlPrefix}/serverless` }]\n    : [{ paths: [`${distDir}/server/pages/`], urlPrefix: `${urlPrefix}/server/pages` }].concat(\n        isWebpack5 ? [{ paths: [`${distDir}/server/chunks/`], urlPrefix: `${urlPrefix}/server/chunks` }] : [],\n      );\n\n  const clientInclude = userNextConfig.sentry?.widenClientFileUpload\n    ? [{ paths: [`${distDir}/static/chunks`], urlPrefix: `${urlPrefix}/static/chunks` }]\n    : [{ paths: [`${distDir}/static/chunks/pages`], urlPrefix: `${urlPrefix}/static/chunks/pages` }];\n\n  const defaultPluginOptions = dropUndefinedKeys({\n    include: isServer ? serverInclude : clientInclude,\n    ignore:\n      isServer || !userNextConfig.sentry?.widenClientFileUpload\n        ? []\n        : // Widening the upload scope is necessarily going to lead to us uploading files we don't need to (ones which\n          // don't include any user code). In order to lessen that where we can, exclude the internal nextjs files we know\n          // will be there.\n          ['framework-*', 'framework.*', 'main-*', 'polyfills-*', 'webpack-*'],\n    url: process.env.SENTRY_URL,\n    org: process.env.SENTRY_ORG,\n    project: process.env.SENTRY_PROJECT,\n    authToken: process.env.SENTRY_AUTH_TOKEN,\n    configFile: hasSentryProperties ? 'sentry.properties' : undefined,\n    stripPrefix: ['webpack://_N_E/'],\n    urlPrefix,\n    entries: (entryPointName: string) => shouldAddSentryToEntryPoint(entryPointName, isServer),\n    release: getSentryRelease(buildId),\n    dryRun: isDev,\n  });\n\n  checkWebpackPluginOverrides(defaultPluginOptions, userPluginOptions);\n\n  return { ...defaultPluginOptions, ...userPluginOptions };\n}\n\n/**\n * NOTE: `eval` usage is a workaround for @vercel/nft detecting the binary itself as the hard dependency\n *       and effectively always including it in the bundle, which is not what we want.\n * ref: https://github.com/getsentry/sentry-javascript/issues/3865\n * ref: https://github.com/vercel/nft/issues/203\n */\nfunction ensureCLIBinaryExists(): boolean {\n  return eval(\"fs.existsSync(path.join(require.resolve('@sentry/cli'), '../../sentry-cli'))\");\n}\n"],"names":[],"mappings":";;;;;;;;;AAoBA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+DA;;AAEA;;;;;;;;;AASA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCA;;AAEA;;;;;;;;;;;;;;;;;;AAkBA;;AAEA;;;;;;;AAOA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;;AAEA;;;;;;;;AAQA;;;AAGA;;;;;;;;;;;AAWA;;AAEA;;;;;;;AAOA;;;;;;AAMA;;AAEA;;;;;;;;;;;AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA;;AAEA;;;;;;AAMA;;AAEA;;"}